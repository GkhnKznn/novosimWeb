# -*- coding: utf-8 -*-
"""rpm_fix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15cf3xqZpNSnn42bHStDOltmA7n-MsEl0
"""

import struct
import numpy as np
import pandas as pd

class ReadRPC:
    def __init__(self, filepath):
        self.filepath = filepath
        self.header = {}
        self.channels = []
        self.channel_objects = []
        self.dt = 0.0

    def parse(self):
        with open(self.filepath, 'rb') as f:
            self._read_header(f)
            self._read_data(f)

    def _read_header(self, f):
        def parse_block(f):
            block = f.read(128)
            if len(block) < 128:
                return None, None
            key = block[:32].decode('windows-1251').replace('\0', '').strip()
            val = block[32:].decode('windows-1251').replace('\0', '').strip()
            return key, val

        for i in range(3):
            key, val = parse_block(f)
            if key in ['NUM_HEADER_BLOCKS', 'NUM_PARAMS']:
                self.header[key] = int(val)
            else:
                self.header[key] = val

        for _ in range(self.header['NUM_PARAMS'] - 3):
            key, val = parse_block(f)
            self.header[key] = val

        self.header['CHANNELS'] = int(self.header['CHANNELS'])
        self.header['DELTA_T'] = float(self.header['DELTA_T'])
        self.header['PTS_PER_FRAME'] = int(self.header['PTS_PER_FRAME'])
        self.header['PTS_PER_GROUP'] = int(self.header['PTS_PER_GROUP'])
        self.header['FRAMES'] = int(self.header['FRAMES'])
        self.dt = self.header['DELTA_T']

        for i in range(self.header['CHANNELS']):
            name = self.header.get(f'DESC.CHAN_{i+1}', f'Ch_{i+1}')
            scale = float(self.header.get(f'SCALE.CHAN_{i+1}', 1.0))
            units = self.header.get(f'UNITS.CHAN_{i+1}', '')
            self.channel_objects.append({'name': name, 'scale': scale, 'units': units, 'data': []})

    def _read_data(self, f):
        channels = self.header['CHANNELS']
        pts_per_frame = self.header['PTS_PER_FRAME']
        pts_per_group = self.header['PTS_PER_GROUP']
        frames = self.header['FRAMES']
        data_type = self.header['DATA_TYPE']

        if data_type == 'SHORT_INTEGER':
            fmt = 'h'
            size = 2
        elif data_type == 'FLOATING_POINT':
            fmt = 'f'
            size = 4
        else:
            raise ValueError("Unknown DATA_TYPE")

        group_frames = pts_per_group // pts_per_frame
        num_groups = int(np.ceil(frames / group_frames))

        data_offset = int(self.header['NUM_HEADER_BLOCKS']) * 512
        f.seek(data_offset)

        data_order = []
        frame_no = 1
        for i in range(num_groups):
            temp = []
            for j in range(group_frames):
                if frame_no > frames:
                    break
                temp.append(frame_no)
                frame_no += 1
            data_order.append(temp)

        for group in data_order:
            for ch in range(channels):
                scale = self.channel_objects[ch]['scale']
                for _ in group:
                    buffer = f.read(pts_per_frame * size)
                    data = struct.unpack(f'<{pts_per_frame}{fmt}', buffer)
                    self.channel_objects[ch]['data'].extend([d * scale for d in data])

    def to_dataframe(self):
        time = np.arange(0, len(self.channel_objects[0]['data'])) * self.dt
        df = pd.DataFrame({'Time (s)': time})
        for ch in self.channel_objects:
            df[ch['name']] = ch['data']
        return df






